// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ITEMPROTOS_DB_H_
#define FLATBUFFERS_GENERATED_ITEMPROTOS_DB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "item_affix_generated.h"
#include "item_class_generated.h"
#include "item_type_generated.h"

namespace DB {

struct ItemProto;
struct ItemProtoBuilder;
struct ItemProtoT;

struct ItemProtoDB;
struct ItemProtoDBBuilder;
struct ItemProtoDBT;

struct ItemProtoT : public flatbuffers::NativeTable {
  typedef ItemProto TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "DB.ItemProtoT";
  }
  ItemType item_type = ItemType_empty;
  ItemClass item_class = ItemClass_system;
  std::string name_singular{};
  std::string name_plural{};
  uint8_t stack_limit = 0;
  std::vector<std::unique_ptr<ItemAffixProtoT>> affixes{};
  ItemProtoT() = default;
  ItemProtoT(const ItemProtoT &o);
  ItemProtoT(ItemProtoT&&) FLATBUFFERS_NOEXCEPT = default;
  ItemProtoT &operator=(ItemProtoT o) FLATBUFFERS_NOEXCEPT;
};

struct ItemProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemProtoT NativeTableType;
  typedef ItemProtoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "DB.ItemProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_TYPE = 4,
    VT_ITEM_CLASS = 6,
    VT_NAME_SINGULAR = 8,
    VT_NAME_PLURAL = 10,
    VT_STACK_LIMIT = 12,
    VT_AFFIXES = 14
  };
  ItemType item_type() const {
    return static_cast<ItemType>(GetField<uint16_t>(VT_ITEM_TYPE, 0));
  }
  bool mutate_item_type(ItemType _item_type = static_cast<ItemType>(0)) {
    return SetField<uint16_t>(VT_ITEM_TYPE, static_cast<uint16_t>(_item_type), 0);
  }
  bool KeyCompareLessThan(const ItemProto *o) const {
    return item_type() < o->item_type();
  }
  int KeyCompareWithValue(uint16_t _item_type) const {
    return static_cast<int>(item_type() > _item_type) - static_cast<int>(item_type() < _item_type);
  }
  ItemClass item_class() const {
    return static_cast<ItemClass>(GetField<uint8_t>(VT_ITEM_CLASS, 0));
  }
  bool mutate_item_class(ItemClass _item_class = static_cast<ItemClass>(0)) {
    return SetField<uint8_t>(VT_ITEM_CLASS, static_cast<uint8_t>(_item_class), 0);
  }
  const flatbuffers::String *name_singular() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_SINGULAR);
  }
  flatbuffers::String *mutable_name_singular() {
    return GetPointer<flatbuffers::String *>(VT_NAME_SINGULAR);
  }
  const flatbuffers::String *name_plural() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_PLURAL);
  }
  flatbuffers::String *mutable_name_plural() {
    return GetPointer<flatbuffers::String *>(VT_NAME_PLURAL);
  }
  uint8_t stack_limit() const {
    return GetField<uint8_t>(VT_STACK_LIMIT, 0);
  }
  bool mutate_stack_limit(uint8_t _stack_limit = 0) {
    return SetField<uint8_t>(VT_STACK_LIMIT, _stack_limit, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>> *affixes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>> *>(VT_AFFIXES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>> *mutable_affixes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>> *>(VT_AFFIXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ITEM_TYPE, 2) &&
           VerifyField<uint8_t>(verifier, VT_ITEM_CLASS, 1) &&
           VerifyOffset(verifier, VT_NAME_SINGULAR) &&
           verifier.VerifyString(name_singular()) &&
           VerifyOffset(verifier, VT_NAME_PLURAL) &&
           verifier.VerifyString(name_plural()) &&
           VerifyField<uint8_t>(verifier, VT_STACK_LIMIT, 1) &&
           VerifyOffset(verifier, VT_AFFIXES) &&
           verifier.VerifyVector(affixes()) &&
           verifier.VerifyVectorOfTables(affixes()) &&
           verifier.EndTable();
  }
  ItemProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemProtoBuilder {
  typedef ItemProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(ItemType item_type) {
    fbb_.AddElement<uint16_t>(ItemProto::VT_ITEM_TYPE, static_cast<uint16_t>(item_type), 0);
  }
  void add_item_class(ItemClass item_class) {
    fbb_.AddElement<uint8_t>(ItemProto::VT_ITEM_CLASS, static_cast<uint8_t>(item_class), 0);
  }
  void add_name_singular(flatbuffers::Offset<flatbuffers::String> name_singular) {
    fbb_.AddOffset(ItemProto::VT_NAME_SINGULAR, name_singular);
  }
  void add_name_plural(flatbuffers::Offset<flatbuffers::String> name_plural) {
    fbb_.AddOffset(ItemProto::VT_NAME_PLURAL, name_plural);
  }
  void add_stack_limit(uint8_t stack_limit) {
    fbb_.AddElement<uint8_t>(ItemProto::VT_STACK_LIMIT, stack_limit, 0);
  }
  void add_affixes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>>> affixes) {
    fbb_.AddOffset(ItemProto::VT_AFFIXES, affixes);
  }
  explicit ItemProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemProto> CreateItemProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    ItemType item_type = ItemType_empty,
    ItemClass item_class = ItemClass_system,
    flatbuffers::Offset<flatbuffers::String> name_singular = 0,
    flatbuffers::Offset<flatbuffers::String> name_plural = 0,
    uint8_t stack_limit = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ItemAffixProto>>> affixes = 0) {
  ItemProtoBuilder builder_(_fbb);
  builder_.add_affixes(affixes);
  builder_.add_name_plural(name_plural);
  builder_.add_name_singular(name_singular);
  builder_.add_item_type(item_type);
  builder_.add_stack_limit(stack_limit);
  builder_.add_item_class(item_class);
  return builder_.Finish();
}

inline flatbuffers::Offset<ItemProto> CreateItemProtoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ItemType item_type = ItemType_empty,
    ItemClass item_class = ItemClass_system,
    const char *name_singular = nullptr,
    const char *name_plural = nullptr,
    uint8_t stack_limit = 0,
    const std::vector<flatbuffers::Offset<ItemAffixProto>> *affixes = nullptr) {
  auto name_singular__ = name_singular ? _fbb.CreateString(name_singular) : 0;
  auto name_plural__ = name_plural ? _fbb.CreateString(name_plural) : 0;
  auto affixes__ = affixes ? _fbb.CreateVector<flatbuffers::Offset<ItemAffixProto>>(*affixes) : 0;
  return DB::CreateItemProto(
      _fbb,
      item_type,
      item_class,
      name_singular__,
      name_plural__,
      stack_limit,
      affixes__);
}

flatbuffers::Offset<ItemProto> CreateItemProto(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemProtoDBT : public flatbuffers::NativeTable {
  typedef ItemProtoDB TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "DB.ItemProtoDBT";
  }
  std::vector<std::unique_ptr<DB::ItemProtoT>> protos{};
  ItemProtoDBT() = default;
  ItemProtoDBT(const ItemProtoDBT &o);
  ItemProtoDBT(ItemProtoDBT&&) FLATBUFFERS_NOEXCEPT = default;
  ItemProtoDBT &operator=(ItemProtoDBT o) FLATBUFFERS_NOEXCEPT;
};

struct ItemProtoDB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemProtoDBT NativeTableType;
  typedef ItemProtoDBBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "DB.ItemProtoDB";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>> *protos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>> *>(VT_PROTOS);
  }
  flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>> *mutable_protos() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>> *>(VT_PROTOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOS) &&
           verifier.VerifyVector(protos()) &&
           verifier.VerifyVectorOfTables(protos()) &&
           verifier.EndTable();
  }
  ItemProtoDBT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemProtoDBT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemProtoDB> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoDBT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemProtoDBBuilder {
  typedef ItemProtoDB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>>> protos) {
    fbb_.AddOffset(ItemProtoDB::VT_PROTOS, protos);
  }
  explicit ItemProtoDBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemProtoDB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemProtoDB>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemProtoDB> CreateItemProtoDB(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DB::ItemProto>>> protos = 0) {
  ItemProtoDBBuilder builder_(_fbb);
  builder_.add_protos(protos);
  return builder_.Finish();
}

inline flatbuffers::Offset<ItemProtoDB> CreateItemProtoDBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<flatbuffers::Offset<DB::ItemProto>> *protos = nullptr) {
  auto protos__ = protos ? _fbb.CreateVectorOfSortedTables<DB::ItemProto>(protos) : 0;
  return DB::CreateItemProtoDB(
      _fbb,
      protos__);
}

flatbuffers::Offset<ItemProtoDB> CreateItemProtoDB(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoDBT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ItemProtoT::ItemProtoT(const ItemProtoT &o)
      : item_type(o.item_type),
        item_class(o.item_class),
        name_singular(o.name_singular),
        name_plural(o.name_plural),
        stack_limit(o.stack_limit) {
  affixes.reserve(o.affixes.size());
  for (const auto &affixes_ : o.affixes) { affixes.emplace_back((affixes_) ? new ItemAffixProtoT(*affixes_) : nullptr); }
}

inline ItemProtoT &ItemProtoT::operator=(ItemProtoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(item_type, o.item_type);
  std::swap(item_class, o.item_class);
  std::swap(name_singular, o.name_singular);
  std::swap(name_plural, o.name_plural);
  std::swap(stack_limit, o.stack_limit);
  std::swap(affixes, o.affixes);
  return *this;
}

inline ItemProtoT *ItemProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemProtoT>(new ItemProtoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemProto::UnPackTo(ItemProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = item_type(); _o->item_type = _e; }
  { auto _e = item_class(); _o->item_class = _e; }
  { auto _e = name_singular(); if (_e) _o->name_singular = _e->str(); }
  { auto _e = name_plural(); if (_e) _o->name_plural = _e->str(); }
  { auto _e = stack_limit(); _o->stack_limit = _e; }
  { auto _e = affixes(); if (_e) { _o->affixes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->affixes[_i]) { _e->Get(_i)->UnPackTo(_o->affixes[_i].get(), _resolver); } else { _o->affixes[_i] = std::unique_ptr<ItemAffixProtoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->affixes.resize(0); } }
}

inline flatbuffers::Offset<ItemProto> ItemProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemProto> CreateItemProto(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _item_type = _o->item_type;
  auto _item_class = _o->item_class;
  auto _name_singular = _o->name_singular.empty() ? 0 : _fbb.CreateString(_o->name_singular);
  auto _name_plural = _o->name_plural.empty() ? 0 : _fbb.CreateString(_o->name_plural);
  auto _stack_limit = _o->stack_limit;
  auto _affixes = _o->affixes.size() ? _fbb.CreateVector<flatbuffers::Offset<ItemAffixProto>> (_o->affixes.size(), [](size_t i, _VectorArgs *__va) { return CreateItemAffixProto(*__va->__fbb, __va->__o->affixes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return DB::CreateItemProto(
      _fbb,
      _item_type,
      _item_class,
      _name_singular,
      _name_plural,
      _stack_limit,
      _affixes);
}

inline ItemProtoDBT::ItemProtoDBT(const ItemProtoDBT &o) {
  protos.reserve(o.protos.size());
  for (const auto &protos_ : o.protos) { protos.emplace_back((protos_) ? new DB::ItemProtoT(*protos_) : nullptr); }
}

inline ItemProtoDBT &ItemProtoDBT::operator=(ItemProtoDBT o) FLATBUFFERS_NOEXCEPT {
  std::swap(protos, o.protos);
  return *this;
}

inline ItemProtoDBT *ItemProtoDB::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemProtoDBT>(new ItemProtoDBT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemProtoDB::UnPackTo(ItemProtoDBT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protos(); if (_e) { _o->protos.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->protos[_i]) { _e->Get(_i)->UnPackTo(_o->protos[_i].get(), _resolver); } else { _o->protos[_i] = std::unique_ptr<DB::ItemProtoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->protos.resize(0); } }
}

inline flatbuffers::Offset<ItemProtoDB> ItemProtoDB::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoDBT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemProtoDB(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemProtoDB> CreateItemProtoDB(flatbuffers::FlatBufferBuilder &_fbb, const ItemProtoDBT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemProtoDBT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protos = _o->protos.size() ? _fbb.CreateVector<flatbuffers::Offset<DB::ItemProto>> (_o->protos.size(), [](size_t i, _VectorArgs *__va) { return CreateItemProto(*__va->__fbb, __va->__o->protos[i].get(), __va->__rehasher); }, &_va ) : 0;
  return DB::CreateItemProtoDB(
      _fbb,
      _protos);
}

inline const DB::ItemProtoDB *GetItemProtoDB(const void *buf) {
  return flatbuffers::GetRoot<DB::ItemProtoDB>(buf);
}

inline const DB::ItemProtoDB *GetSizePrefixedItemProtoDB(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DB::ItemProtoDB>(buf);
}

inline ItemProtoDB *GetMutableItemProtoDB(void *buf) {
  return flatbuffers::GetMutableRoot<ItemProtoDB>(buf);
}

inline DB::ItemProtoDB *GetMutableSizePrefixedItemProtoDB(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<DB::ItemProtoDB>(buf);
}

inline const char *ItemProtoDBIdentifier() {
  return "IPRO";
}

inline bool ItemProtoDBBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ItemProtoDBIdentifier());
}

inline bool SizePrefixedItemProtoDBBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ItemProtoDBIdentifier(), true);
}

inline bool VerifyItemProtoDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DB::ItemProtoDB>(ItemProtoDBIdentifier());
}

inline bool VerifySizePrefixedItemProtoDBBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DB::ItemProtoDB>(ItemProtoDBIdentifier());
}

inline const char *ItemProtoDBExtension() {
  return "ipr";
}

inline void FinishItemProtoDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DB::ItemProtoDB> root) {
  fbb.Finish(root, ItemProtoDBIdentifier());
}

inline void FinishSizePrefixedItemProtoDBBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DB::ItemProtoDB> root) {
  fbb.FinishSizePrefixed(root, ItemProtoDBIdentifier());
}

inline std::unique_ptr<DB::ItemProtoDBT> UnPackItemProtoDB(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DB::ItemProtoDBT>(GetItemProtoDB(buf)->UnPack(res));
}

inline std::unique_ptr<DB::ItemProtoDBT> UnPackSizePrefixedItemProtoDB(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<DB::ItemProtoDBT>(GetSizePrefixedItemProtoDB(buf)->UnPack(res));
}

}  // namespace DB

#endif  // FLATBUFFERS_GENERATED_ITEMPROTOS_DB_H_

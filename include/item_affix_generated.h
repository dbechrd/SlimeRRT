// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ITEMAFFIX_H_
#define FLATBUFFERS_GENERATED_ITEMAFFIX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

struct ItemAffixProto;
struct ItemAffixProtoBuilder;
struct ItemAffixProtoT;

struct ItemAffix;
struct ItemAffixBuilder;
struct ItemAffixT;

enum ItemAffixType : uint8_t {
  ItemAffixType_empty = 0,
  ItemAffixType_damage_min = 1,
  ItemAffixType_damage_max = 2,
  ItemAffixType_knockback_min = 3,
  ItemAffixType_knockback_max = 4,
  ItemAffixType_knockback_pct_damage = 5,
  ItemAffixType_move_speed = 6,
  ItemAffixType_value = 7,
  ItemAffixType_MIN = ItemAffixType_empty,
  ItemAffixType_MAX = ItemAffixType_value
};

inline const ItemAffixType (&EnumValuesItemAffixType())[8] {
  static const ItemAffixType values[] = {
    ItemAffixType_empty,
    ItemAffixType_damage_min,
    ItemAffixType_damage_max,
    ItemAffixType_knockback_min,
    ItemAffixType_knockback_max,
    ItemAffixType_knockback_pct_damage,
    ItemAffixType_move_speed,
    ItemAffixType_value
  };
  return values;
}

inline const char * const *EnumNamesItemAffixType() {
  static const char * const names[9] = {
    "empty",
    "damage_min",
    "damage_max",
    "knockback_min",
    "knockback_max",
    "knockback_pct_damage",
    "move_speed",
    "value",
    nullptr
  };
  return names;
}

inline const char *EnumNameItemAffixType(ItemAffixType e) {
  if (flatbuffers::IsOutRange(e, ItemAffixType_empty, ItemAffixType_value)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesItemAffixType()[index];
}

struct ItemAffixProtoT : public flatbuffers::NativeTable {
  typedef ItemAffixProto TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "ItemAffixProtoT";
  }
  ItemAffixType type = ItemAffixType_empty;
  uint8_t min = 0;
  uint8_t max = 0;
};

struct ItemAffixProto FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemAffixProtoT NativeTableType;
  typedef ItemAffixProtoBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "ItemAffixProto";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_MIN = 6,
    VT_MAX = 8
  };
  ItemAffixType type() const {
    return static_cast<ItemAffixType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(ItemAffixType _type = static_cast<ItemAffixType>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint8_t min() const {
    return GetField<uint8_t>(VT_MIN, 0);
  }
  bool mutate_min(uint8_t _min = 0) {
    return SetField<uint8_t>(VT_MIN, _min, 0);
  }
  uint8_t max() const {
    return GetField<uint8_t>(VT_MAX, 0);
  }
  bool mutate_max(uint8_t _max = 0) {
    return SetField<uint8_t>(VT_MAX, _max, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MIN, 1) &&
           VerifyField<uint8_t>(verifier, VT_MAX, 1) &&
           verifier.EndTable();
  }
  ItemAffixProtoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemAffixProtoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemAffixProto> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemAffixProtoBuilder {
  typedef ItemAffixProto Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ItemAffixType type) {
    fbb_.AddElement<uint8_t>(ItemAffixProto::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_min(uint8_t min) {
    fbb_.AddElement<uint8_t>(ItemAffixProto::VT_MIN, min, 0);
  }
  void add_max(uint8_t max) {
    fbb_.AddElement<uint8_t>(ItemAffixProto::VT_MAX, max, 0);
  }
  explicit ItemAffixProtoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemAffixProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemAffixProto>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemAffixProto> CreateItemAffixProto(
    flatbuffers::FlatBufferBuilder &_fbb,
    ItemAffixType type = ItemAffixType_empty,
    uint8_t min = 0,
    uint8_t max = 0) {
  ItemAffixProtoBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ItemAffixProto> CreateItemAffixProto(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ItemAffixT : public flatbuffers::NativeTable {
  typedef ItemAffix TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "ItemAffixT";
  }
  ItemAffixType type = ItemAffixType_empty;
  uint8_t value = 0;
};

struct ItemAffix FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ItemAffixT NativeTableType;
  typedef ItemAffixBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "ItemAffix";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  ItemAffixType type() const {
    return static_cast<ItemAffixType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(ItemAffixType _type = static_cast<ItemAffixType>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool mutate_value(uint8_t _value = 0) {
    return SetField<uint8_t>(VT_VALUE, _value, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  ItemAffixT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ItemAffixT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ItemAffix> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ItemAffixBuilder {
  typedef ItemAffix Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ItemAffixType type) {
    fbb_.AddElement<uint8_t>(ItemAffix::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(ItemAffix::VT_VALUE, value, 0);
  }
  explicit ItemAffixBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ItemAffix> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ItemAffix>(end);
    return o;
  }
};

inline flatbuffers::Offset<ItemAffix> CreateItemAffix(
    flatbuffers::FlatBufferBuilder &_fbb,
    ItemAffixType type = ItemAffixType_empty,
    uint8_t value = 0) {
  ItemAffixBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ItemAffix> CreateItemAffix(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ItemAffixProtoT *ItemAffixProto::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemAffixProtoT>(new ItemAffixProtoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemAffixProto::UnPackTo(ItemAffixProtoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
}

inline flatbuffers::Offset<ItemAffixProto> ItemAffixProto::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixProtoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemAffixProto(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemAffixProto> CreateItemAffixProto(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixProtoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemAffixProtoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _min = _o->min;
  auto _max = _o->max;
  return CreateItemAffixProto(
      _fbb,
      _type,
      _min,
      _max);
}

inline ItemAffixT *ItemAffix::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ItemAffixT>(new ItemAffixT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ItemAffix::UnPackTo(ItemAffixT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<ItemAffix> ItemAffix::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateItemAffix(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ItemAffix> CreateItemAffix(flatbuffers::FlatBufferBuilder &_fbb, const ItemAffixT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ItemAffixT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _value = _o->value;
  return CreateItemAffix(
      _fbb,
      _type,
      _value);
}

#endif  // FLATBUFFERS_GENERATED_ITEMAFFIX_H_
